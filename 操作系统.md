## 1. 处理器调度

1. 高级调度（作业调度）
   1.  把外存上处于后备状态的作业选择一个或者多个给它们建立进程并分配资源，频率较低（几分钟一次）
   2. 执行作业调度，要解决两个问题：
      1. 每次要接纳多少作业进入内存？
         1. 取决于系统的规模和运行速度
         2. 内存中同时运行的作业太多，会导致周转时间较长；同时运行的作业太少，会导致系统利用率和吞吐量下降
      2. 将哪些作业调入内存？
         1. 取决于采取的调度算法
      3. 

2. 中级调度
   1. 将处于外存对换区中的具备运行条件的进程带哦如内存，并将其状态改为就绪状态；或将处于内存中的暂时不能运行进程交换到外村对换区，将此时的状态称为挂起状态。

3. 低级调度（进程调度）
   1. 从就绪队列中选取一个进程，将处理器分配给它。（频率很高，一般隔几十毫秒运行一次）
4. 注意差异：
   1. 简单来说，作业调度的结果是为作业创建进程，而进程调度的结果是进程被执行。
   2. 
5. 调度的基本原则（调度算法优劣的评价标准）：
   1. CPU利用率
   2. 系统吞吐量
   3. 响应时间
   4. 周转时间
      1. 周转时间 ------ 作业从提交到完成的时间间隔
      2. 平均周转时间 ------ 多个作业周转时间的平均值
      3. 带权周转时间 ------ 作业的周转时间 / 作业的运行时间
      4. 平均带权周转时间 ------ 多个作业的带权周转时间的平均值
6. 进程调度：
   1. 处理器分配的任务（进程调度）有由程调度程序完成。
   2. 不能进行进程调度的情况：
      1. 处理中断的过程中。
      2. 在操作系统内核临界区中。
      3. 其他需要完全屏蔽中断的原子操作过程中。
   3. 进程调度的方式：
      1. 抢占式：有某个优先级更高的进程进入就绪队列，则立即暂停正在执行的进程，将处理器分配给那个优先级更高的进程。
      2. 非抢占式：
7. 常见调度算法：
   1. 先来先服务调度算法（FCFS）
   2. 短作业优先调度算法（SJF）
   3. 优先级调度算法
   4. 时间片轮转调度算法 ------ 只适用于进程调度
   5. 高响应比优先调度算法 ------ 只适用作业调度
      1. 响应比：（作业等待时间 + 估计运行时间）/ 估计运行时间
   6. 多级队列调度算法 ------ 只适用于进程调度
      1. 将就绪队列分为若干个不同的队列，不同队列可以采用不同的调度算法。
   7. 多级反馈队列调度算法 ------ 只适用于进程调度





****





## 2. 内存管理



### 1. 概述：

1. 内存管理的功能：
   1. **内存的分配和回收。**
   2. **地址变换**：将程序中的逻辑地址转换为内存中的物理地址。
      1. ![image-20220405154154228](https://gitee.com/nothingimpossible/study-notes-img/raw/master/marktext_img/image-20220405154154228.png)
   3. **扩充内存**：借助**虚拟内存**技术或其他自动覆盖技术，实现在**逻辑上**扩充内存的目的。
   4. **存储保护**：保证进入内存的各道作业都在自己的存储空间内运行，互不干扰。
2. 应用程序的编译、链接和装入：
   1. **编译**（Complier）：将源代码编译为若干个目标模块（Object Module）。
   2. **链接**（Linker）：将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块（Load Module）。
      - **静态链接**：程序运行前，把各个目标模块及所需库链接成一个完整的可执行程序，以后不再拆开。
      - **装入时动态链接**：将应用程序编译后所得到的一组目标模块装入内存时采用**边装入边链接**的动态链接方式。
      - **运行时动态链接**：在执行过程中，发现一个被调用模块尚未装入内存时，立即去找到该模块并将其转入内存，然后把它链接到调用者模块上。
   3. **装入**（Loader）：将这些装入模块装入内存并执行。
      1. **绝对装入**：编译程序产生含有物理地址的目标代码。
      2. **可重定位装入**：根据内存当前情况，将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，之后不再改变，也称为静态重定位。
      3. **动态运行装入**：
3. 逻辑地址和物理地址：
4. 内存和保护：

 

### 2. 覆盖与交换：

1. **覆盖技术**：
   1. 覆盖段：把程序执行时并不要求同时装入内存的覆盖组成一组。
   2. 覆盖区：将这个覆盖段分配到同一个存储区域，这个存储区域称为覆盖区。
2. **交换技术**：
   1. 交换(Swapping)技术是指把暂时不用的某个程序及数据部分(或全部)从内存移到外存中，以便腾出必要的内存空间；或把指定的程序或数据从外存读到相应的内存中，并将将制权转给它，让其在系统上运行的一种内存扩充技术。处理器三级调度中的中级调度就是采用了交换技术。



### 3. 连续分配管理方式：

1. 碎片：
   1. 内部碎片：已经分配给作业但不能被利用的内存空间。
   2. 外部碎片：系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块。
2. 单一连续分配：只能用于单用户、单任务的操作系统。内存分为两个连续的存储区域，低地址分配给操作系统，高地址分配给用户。采用**静态分配**，适合单道程序，可采用覆盖技术。作业一旦进入内存，就要等待其结束后才能释放。
3. 固定分区分配：最早使用的一种可运行多道程序的存储管理方法。内存划分为若干个固定大小的分区，分区大小可以不等，但**运行时不能改变**。固定分区分配中，程序通常采用**静态重定位方式**装入内存。



### 4. 非连续分配管理方式：

1. 分页存储管理方式：
   1. 进程地址空间分成一个个页，内存分成一个个页框，页和页框的大小相同。页和页框内又分页内地址。连续的页可以分配至不连续的页框。
   2. **页表**记录着 页号和页框号的对应关系。页表保存在内存的一段连续空间中，是进程的一部分。那么我们怎么找到页表呢？很简单，因为页表存储在一段连续的内存中，所以我们只需要知道页表的**起始地址**即可。进程正在执行时，页表起始地址保存在页表基址寄存器；若进程没有在执行，则页表起始地址保存在PCB中。
2. 段式存储管理方式：
   1. 每一段是一片连续的存储空间，但段与段之间可以是不连续的。段的分配原则是一段有含义的程序为一段。
   2. **段表**记录着进程地址空间与内存地址之间的对应关系。段表中的逻辑段号记录进程地址空间中的哪一段，然后是段长，再后面是基址（该段在内存中的起始地址）。
3. 段页式存储管理方式：
   1. 先按照逻辑关系划分为段，然后每一段再按页面划分。
   2. <img src="https://gitee.com/nothingimpossible/study-notes-img/raw/master/marktext_img/image-20220407200858796.png" alt="image-20220407200858796" style="zoom:50%;" />



### 5. 虚拟内存管理： 

1. 解决的问题：进程所需要的存储空间已经超出了内存总容量
2. 覆盖技术：让不会同时执行的程序模块共享一片存储区。
3. 交换（对换）技术：将暂不执行的进程换出内存，将满足执行条件的进程换入内存。换入换出的单位是整个进程。
4. 覆盖与交换的对比：
   1. 覆盖发生在同一个进程内的不同时执行的模块间；交换则是以进程为基本单位。
   2. 覆盖解决一个进程的空间需求无法满足的问题；交换解决多个进程的空间需求无法满足的的问题。
5. 局部性原理：
   1. 时间局部性、空间局部性、分支局部性。
6. 虚拟存储技术：
   1. 原理：
      1. 执行过程中需要的程序或者数据才调入内存，暂时不用的页或者段调出并保存到外存中（把谁调出内存取决于选用的页面置换算法）。
   2. 实现方式：
      1. 虚拟页式存储方式和虚拟段式存储方式。
      2. 考纲要求是虚拟页式存储：
         1. 页号 + 框号 + 状态位P + 访问字段A + 修改位M + 外存地址
            1. P：用于指示该页是否已装入内存。
               1. 若是根据这个字段判断出该页不在内存中，则会产生缺页中断，于是把该页调入内存中。
            2. A：用于记录本页在一段时间内被访问的次数或最近已有多久未被访问。
            3. M：用于表示该页是否已被修改，而使得内容与外存中的备份不同。
            4. 外存地址：用于指出该页在外存上备份的地址。
   3. 页面置换算法：
      1. 最佳置换（OPT）算法（因为需要预知未来，所以是一种理想算法）。
      2. 先进先出（FIFO）算法
      3. 最近最久未使用（LRU）算法
      4. 时钟置换（CLOCK）算法
